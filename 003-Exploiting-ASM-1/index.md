---
title: "Exploiting the OW2 ASM Library's Parser"
---

As an obfuscator developer it is my job to attempt to prevent reverse engineers from analyzing customer's applications.

One common tool used by Java reverse engineers is [The OW2 ASM Library](https://gitlab.ow2.org/asm/asm/), a library that can read, manipulate and write class files generated by the javac compiler. This makes ASM a target for obfuscation -- hindering the functionality of ASM on obfuscated classes can be very valuable.

In this post I'll go over how I found and exploited a design flaw in the ASM library in order to create classfiles that render ASM useless.

<!--more-->

## Well Known Attributes

The JVM class file specification allows many structures to have attributes, for example fields and methods. These attributes are basically a section of bytes with a user defined name. For example, a custom attribute could be used to provide extra metadata to debuggers. Some attributes are "Well Known", meaning that the name and structure of the attribute is known to and hardcoded within the JVM. 

An example of this is the `Code` attribute. When the JVM encounters an attribute within a method with the name `Code` it will be parsed according to [the definition of the code attribute within the JVM specification](https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7.3).

What is interesting however is when a new Java release results in the addition of a new attribute. This happened in Java 11, when the introduction of Nest-Based Access Control (JEP 181: Allow separate classes to access each other's private members) resulted in the `NestMembers` attribute being [defined in the JVM specification](https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jvms-4.7.29). 

There is an issue here -- since compilers are allowed to insert user defined attributes into classfiles, what would happen if a Java 10 classfile with a custom `NestMembers` attribute is defined on a Java 11 virtual machine? Well luckily the JVM developers thought of this and the JVM will not parse a well known attribute if the classfile version is less than the version in which the attribute was defined.

## The exploit

While the JVM developers took this issue into consideration, the ASM library developers did not. The library will always try to parse well known attributes, no matter the classfile version. What this means is that we could for example add an attribute with the name `NestMembers` and a length of 0 to a version 8 classfile. ASM would attempt to parse the NestMembers attribute and would basically buffer overflow as it attempts to read data from a 0 length attribute.

I've written a example classfile to demonstrate this behaviour which can be viewed [here](https://github.com/x4e/Blog/blob/master/003-Exploiting-ASM-1/Exploit.jcod). The classfile simply prints "Hello World!" but the key part is the attribute defined at the bottom of it. Essentially this will run absolutely fine on any JVM, however ASM will crash upon attempting to parse the file with the following stacktrace:

```Java
java.lang.ArrayIndexOutOfBoundsException: Index 317 out of bounds for length 317
  at org.objectweb.asm.ClassReader.readUnsignedShort(ClassReader.java:3561)
  at org.objectweb.asm.ClassReader.accept(ClassReader.java:660)
  at org.objectweb.asm.ClassReader.accept(ClassReader.java:394)
```

Looking at [the relevant code](https://gitlab.ow2.org/asm/asm/-/blob/ASM_9_0/asm/src/main/java/org/objectweb/asm/ClassReader.java) we can see the fault:

```Java
  // - The offset of the NestMembers attribute, or 0.
  int nestMembersOffset = 0;
  ...
  int currentAttributeOffset = getFirstAttributeOffset();
  for (int i = readUnsignedShort(currentAttributeOffset - 2); i > 0; --i) {
    // Read the attribute_info's attribute_name and attribute_length fields.
    String attributeName = readUTF8(currentAttributeOffset, charBuffer);
    int attributeLength = readInt(currentAttributeOffset + 2);
    currentAttributeOffset += 6;

    if (Constants.SOURCE_FILE.equals(attributeName)) {
      sourceFile = readUTF8(currentAttributeOffset, charBuffer);
    ...
    } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
      nestMembersOffset = currentAttributeOffset;
    ...
    }
    currentAttributeOffset += attributeLength;
  }
  ...
  // Visit the NestedMembers attribute.
  if (nestMembersOffset != 0) {
    int numberOfNestMembers = readUnsignedShort(nestMembersOffset);
    int currentNestMemberOffset = nestMembersOffset + 2;
    while (numberOfNestMembers-- > 0) {
      classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
      currentNestMemberOffset += 2;
    }
  }
  ...
```

The problem is easily visible here -- the `NestMembers` attribute is always parsed if present, no matter the classfile version. This can be compared to the behaviour of [the Open JDK's classfile parser](https://github.com/openjdk/jdk/blob/0da9cad5f55713bc81f3a0689b8836ff548ad0cf/src/hotspot/share/classfile/classFileParser.cpp#L3715), which clearly avoids this mistake with a `if (_major_version >= JAVA_11_VERSION)`:

```C++
  // Iterate over attributes
  while (attributes_count--) {
    cfs->guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
    const u2 attribute_name_index = cfs->get_u2_fast();
    const u4 attribute_length = cfs->get_u4_fast();
    check_property(
        valid_symbol_at(attribute_name_index),
        "Attribute name has bad constant pool index %u in class file %s",
        attribute_name_index, CHECK);
    const Symbol* const tag = cp->symbol_at(attribute_name_index);
    if (tag == vmSymbols::tag_source_file()) {
    ...
    } else if (_major_version >= JAVA_11_VERSION) {
      if (tag == vmSymbols::tag_nest_members()) {
        // Check for NestMembers tag
        if (parsed_nest_members_attribute) {
          classfile_parse_error("Multiple NestMembers attributes in class file %s", THREAD);
          return;
        } else {
          parsed_nest_members_attribute = true;
        }
        if (parsed_nest_host_attribute) {
          classfile_parse_error("Conflicting NestHost and NestMembers attributes in class file %s", THREAD);
          return;
        }
        nest_members_attribute_start = cfs->current();
        nest_members_attribute_length = attribute_length;
        cfs->skip_u1(nest_members_attribute_length, CHECK);
      } else if (tag == vmSymbols::tag_nest_host()) {
```

I discovered this exploit while analysing ASM and included it within [my obfuscator](https://binclub.dev/binscure) last year, however since it has now been copied by some of my competitors I thought it would be best to release it as a writeup. Hopefully this helps other people writing classfile parsers to know which pitfalls to avoid.
